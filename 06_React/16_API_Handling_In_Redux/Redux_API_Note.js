//* ****************************************************
//* üìå API Handling In Redux
//* ****************************************************


//* üìå Why Handle APIs in Redux?
    // ‚úÖ APIs are "asynchronous", meaning they take time to complete (e.g., fetching data from a server).
    // ‚úÖ Redux helps manage the state of these API calls globally, so all components can access the data, loading state, and errors.
    // ‚úÖ Redux ensures that state updates are predictable and debuggable.


//* üìå Key Concepts for API Handling in Redux?
    // 1Ô∏è‚É£ Async Thunks:
        // A thunk is a function that wraps an expression to delay its evaluation.
        // In Redux Toolkit, "createAsyncThunk" is used to handle asynchronous logic (e.g., API calls).
        // It automatically generates three action types:
            // 1. Pending: When the API call starts.
            // 2. Fulfilled: When the API call succeeds.
            // 3. Rejected: When the API call fails.

    // 2Ô∏è‚É£ Loading, Success, and Error States:
        // Loading: The request is in progress.
        // Success: The request was successful, and the data is available.
        // Error: The request failed, and an error message is available.

    // 3Ô∏è‚É£ Extra Reducers:
        // Extra reducers are used to handle actions generated by createAsyncThunk (e.g., pending, fulfilled, rejected).
        // They update the state based on the API call status (pending, fulfilled, rejected).


//* üìå How to Handle APIs in Redux?

//* ****************************************************
//* 1Ô∏è‚É£ Create Async Thunks
//* ****************************************************

    // Use "createAsyncThunk" to define async thunks.
    // It takes a "type" and a "callback" function as arguments.
    // The callback function handles the API call and returns the payload.

    //* Example:
    const fetchData = createAsyncThunk(
        'coins/fetch',      // Action type prefix
        async () => {       // Callback function
            const response = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=10`);
            const data = await response.json();
            return data;    // Payload of the fulfilled action
        }
    );

    // The thunk automatically generates three actions:
        // 1. Pending: coins/fetch/pending
        // 2. Fulfilled: coins/fetch/fulfilled
        // 3. Rejected: coins/fetch/rejected


//* ****************************************************
//* 2Ô∏è‚É£ Create a Slice with Extra Reducers
//* ****************************************************

    // Use "extraReducers" to handle actions generated by createAsyncThunk.
    // Extra reducers update the state based on the API call status (pending, fulfilled, rejected).

    //* Example:
    const slice = createSlice({
        name: 'coinSlice',      // Name of the slice
        initialState: {         // Initial state of the slice
            data: [], 
            loading: false, 
            error: null 
        },
        reducers: {},           // Reducers for the slice
        extraReducers: (builder) => {
            builder
                // handle the pending action
                .addcase(fetchData.pending, (state) => {
                    state.loading = true;                   // Set the "loading" state to "true"
                    state.error = null;                     // Set the "error" state to "null"
                })

                // Handle the fulfilled action
                .addcase(fetchData.fulfilled, (state, action) => {
                    state.loading = false;                  // Set the "loading" state to "false"
                    state.data = action.payload;            // Update the "data" state with the payload (API response)
                })

                // Handle the rejected action
                .addcase(fetchData.rejected, (state, action) => {
                    state.loading = false;                  // Set the "loading" state to "false"
                    state.error = action.error.message;     // Update the "error" state with the error message
                })
        },
    });


//* ****************************************************
//* 3Ô∏è‚É£ Add the Slice to the Redux Store
//* ****************************************************

    // To add the slice to the Redux store, use "configureStore" from "@reduxjs/toolkit".
    // It takes the "reducer" as an argument and returns the Redux store.

    //* Example:
    const store = configureStore({
        reducer: {
            // Add the slice reducer to the store
            coinSlice: coinsReducer                     // The "coinsReducer" is added to the store under the "coinSlice" key.
        }
    });


//* ****************************************************
//* 4Ô∏è‚É£ Provide the Redux Store to the App
//* ****************************************************

    // To provide the Redux store to the app, use "Provider" from "react-redux".
    // It takes the Redux store as a prop and wraps the app with the Redux store provider.

    //* Example:
    import { Provider } from 'react-redux';
    import store from './store';

    const App = () => {
        return (
            <Provider store={store}>
                <CoinCard />
            </Provider>
        )
    }


//* ****************************************************
//* 5Ô∏è‚É£ Dispatch the Async Thunk in the Component
//* ****************************************************

    // To dispatch the async thunk, use "dispatch" from the Redux store.
    // It takes the action type as an argument and dispatches the action.

    //* Example:
    import { useEffect } from "react";
    import { useDispatch, useSelector } from "react-redux";

    const CoinData = () => {
        const dispatch = useDispatch();
        const { data, loading, error } = useSelector((state) => state.coinSlice);

        useEffect(() => {
            dispatch(fetchData());      // Dispatch the "fetchData" action
        }, [dispatch]);

        // Display the loading, error states
        if(loading) return <h1>Loading...</h1>;
        if(error) return <h1>Error occurred</h1>;

        // Display the data
        return (
            <div>
                {data.map((coin) => (
                    <div key={coin.id}>
                        <h2>{coin.name}</h2>
                        <p>{coin.symbol}</p>
                        <p>{coin.current_price}</p>
                    </div>
                ))}
            </div>
        );
    }


    //* Explanation:
        // The "useDispatch" hook is used to dispatch the "fetchData" thunk.
        // The "useSelector" hook is used to access the "coinSlice" state from the Redux store.
        // The "useEffect" hook dispatches the "fetchData" thunk when the component mounts.
        // The component displays:
            // - "Loading..." while the data is being fetched.
            // - "Error occurred" if there is an error.
            // - The data if the request is successful.


//* ****************************************************
//* üìå Summary of the Workflow
//* ****************************************************

    // 1Ô∏è‚É£ Create an Async Thunks
        // Use "createAsyncThunk" to define the API call logic.

    // 2Ô∏è‚É£ Create a Slice with Extra Reducers
        // Use "createSlice" to define the initial state and handle the actions generated by the async thunk.
    
    // 3Ô∏è‚É£ Add the Slice to the Redux Store
        // Use "configureStore" to set up the Redux store and include the slice reducer.

    // 4Ô∏è‚É£ Provide the Redux Store to the App
        // Wrap your app with the "Provider" component to make the store available.

    // 5Ô∏è‚É£ Dispatch the Async Thunk in the Component
        // Use "useDispatch" and "useSelector" hooks to dispatch the async thunk and access the state.


//* ****************************************************
//* üìå Key Takeaways
//* ****************************************************

    // ‚úÖ Async Thunk: Handles async logic (e.g., API calls) using "createAsyncThunk".
    // ‚úÖ Slice: Defines the initial state and handles actions using "createSlice".
    // ‚úÖ Store: Holds the entire state of your application using "configureStore".
    // ‚úÖ Provider: Makes the store available to all components using "Provider".
    // ‚úÖ useDispatch: Dispatches actions (e.g., API calls) in components.
    // ‚úÖ useSelector: Accesses state from the Redux store in components.